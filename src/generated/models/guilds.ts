
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `guilds` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model guilds
 * 
 */
export type guildsModel = runtime.Types.Result.DefaultSelection<Prisma.$guildsPayload>

export type AggregateGuilds = {
  _count: GuildsCountAggregateOutputType | null
  _min: GuildsMinAggregateOutputType | null
  _max: GuildsMaxAggregateOutputType | null
}

export type GuildsMinAggregateOutputType = {
  id: string | null
  approved: boolean | null
  roleId: string | null
  lockdownTime: Date | null
}

export type GuildsMaxAggregateOutputType = {
  id: string | null
  approved: boolean | null
  roleId: string | null
  lockdownTime: Date | null
}

export type GuildsCountAggregateOutputType = {
  id: number
  approved: number
  channelsAutopublish: number
  channelsLockdown: number
  roleId: number
  lockdownTime: number
  _all: number
}


export type GuildsMinAggregateInputType = {
  id?: true
  approved?: true
  roleId?: true
  lockdownTime?: true
}

export type GuildsMaxAggregateInputType = {
  id?: true
  approved?: true
  roleId?: true
  lockdownTime?: true
}

export type GuildsCountAggregateInputType = {
  id?: true
  approved?: true
  channelsAutopublish?: true
  channelsLockdown?: true
  roleId?: true
  lockdownTime?: true
  _all?: true
}

export type GuildsAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which guilds to aggregate.
   */
  where?: Prisma.guildsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of guilds to fetch.
   */
  orderBy?: Prisma.guildsOrderByWithRelationInput | Prisma.guildsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.guildsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` guilds from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` guilds.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned guilds
  **/
  _count?: true | GuildsCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: GuildsMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: GuildsMaxAggregateInputType
}

export type GetGuildsAggregateType<T extends GuildsAggregateArgs> = {
      [P in keyof T & keyof AggregateGuilds]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateGuilds[P]>
    : Prisma.GetScalarType<T[P], AggregateGuilds[P]>
}




export type guildsGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.guildsWhereInput
  orderBy?: Prisma.guildsOrderByWithAggregationInput | Prisma.guildsOrderByWithAggregationInput[]
  by: Prisma.GuildsScalarFieldEnum[] | Prisma.GuildsScalarFieldEnum
  having?: Prisma.guildsScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: GuildsCountAggregateInputType | true
  _min?: GuildsMinAggregateInputType
  _max?: GuildsMaxAggregateInputType
}

export type GuildsGroupByOutputType = {
  id: string
  approved: boolean
  channelsAutopublish: string[]
  channelsLockdown: string[]
  roleId: string | null
  lockdownTime: Date | null
  _count: GuildsCountAggregateOutputType | null
  _min: GuildsMinAggregateOutputType | null
  _max: GuildsMaxAggregateOutputType | null
}

type GetGuildsGroupByPayload<T extends guildsGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<GuildsGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof GuildsGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], GuildsGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], GuildsGroupByOutputType[P]>
      }
    >
  >



export type guildsWhereInput = {
  AND?: Prisma.guildsWhereInput | Prisma.guildsWhereInput[]
  OR?: Prisma.guildsWhereInput[]
  NOT?: Prisma.guildsWhereInput | Prisma.guildsWhereInput[]
  id?: Prisma.StringFilter<"guilds"> | string
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableCompositeFilter, Prisma.GuildsAntifakeObjectEqualityInput> | null
  approved?: Prisma.BoolFilter<"guilds"> | boolean
  automessage?: Prisma.AutoMessageCompositeListFilter | Prisma.AutoMessageObjectEqualityInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableCompositeFilter, Prisma.GuildsBackupObjectEqualityInput> | null
  channelsAutopublish?: Prisma.StringNullableListFilter<"guilds">
  channelsLockdown?: Prisma.StringNullableListFilter<"guilds">
  exit?: Prisma.XOR<Prisma.GuildsExitNullableCompositeFilter, Prisma.GuildsExitObjectEqualityInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableCompositeFilter, Prisma.GuildsLogsObjectEqualityInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableCompositeFilter, Prisma.GuildsPartnerWarningObjectEqualityInput> | null
  roleId?: Prisma.StringNullableFilter<"guilds"> | string | null
  rssfeeds?: Prisma.GuildsRssfeedsCompositeListFilter | Prisma.GuildsRssfeedsObjectEqualityInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableCompositeFilter, Prisma.GuildsWelcomeObjectEqualityInput> | null
  lockdownTime?: Prisma.DateTimeNullableFilter<"guilds"> | Date | string | null
}

export type guildsOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  antifake?: Prisma.GuildsAntifakeOrderByInput
  approved?: Prisma.SortOrder
  automessage?: Prisma.AutoMessageOrderByCompositeAggregateInput
  backup?: Prisma.GuildsBackupOrderByInput
  channelsAutopublish?: Prisma.SortOrder
  channelsLockdown?: Prisma.SortOrder
  exit?: Prisma.GuildsExitOrderByInput
  logs?: Prisma.GuildsLogsOrderByInput
  partnerWarning?: Prisma.GuildsPartnerWarningOrderByInput
  roleId?: Prisma.SortOrder
  rssfeeds?: Prisma.GuildsRssfeedsOrderByCompositeAggregateInput
  welcome?: Prisma.GuildsWelcomeOrderByInput
  lockdownTime?: Prisma.SortOrder
}

export type guildsWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.guildsWhereInput | Prisma.guildsWhereInput[]
  OR?: Prisma.guildsWhereInput[]
  NOT?: Prisma.guildsWhereInput | Prisma.guildsWhereInput[]
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableCompositeFilter, Prisma.GuildsAntifakeObjectEqualityInput> | null
  approved?: Prisma.BoolFilter<"guilds"> | boolean
  automessage?: Prisma.AutoMessageCompositeListFilter | Prisma.AutoMessageObjectEqualityInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableCompositeFilter, Prisma.GuildsBackupObjectEqualityInput> | null
  channelsAutopublish?: Prisma.StringNullableListFilter<"guilds">
  channelsLockdown?: Prisma.StringNullableListFilter<"guilds">
  exit?: Prisma.XOR<Prisma.GuildsExitNullableCompositeFilter, Prisma.GuildsExitObjectEqualityInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableCompositeFilter, Prisma.GuildsLogsObjectEqualityInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableCompositeFilter, Prisma.GuildsPartnerWarningObjectEqualityInput> | null
  roleId?: Prisma.StringNullableFilter<"guilds"> | string | null
  rssfeeds?: Prisma.GuildsRssfeedsCompositeListFilter | Prisma.GuildsRssfeedsObjectEqualityInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableCompositeFilter, Prisma.GuildsWelcomeObjectEqualityInput> | null
  lockdownTime?: Prisma.DateTimeNullableFilter<"guilds"> | Date | string | null
}, "id">

export type guildsOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  approved?: Prisma.SortOrder
  channelsAutopublish?: Prisma.SortOrder
  channelsLockdown?: Prisma.SortOrder
  roleId?: Prisma.SortOrder
  lockdownTime?: Prisma.SortOrder
  _count?: Prisma.guildsCountOrderByAggregateInput
  _max?: Prisma.guildsMaxOrderByAggregateInput
  _min?: Prisma.guildsMinOrderByAggregateInput
}

export type guildsScalarWhereWithAggregatesInput = {
  AND?: Prisma.guildsScalarWhereWithAggregatesInput | Prisma.guildsScalarWhereWithAggregatesInput[]
  OR?: Prisma.guildsScalarWhereWithAggregatesInput[]
  NOT?: Prisma.guildsScalarWhereWithAggregatesInput | Prisma.guildsScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"guilds"> | string
  approved?: Prisma.BoolWithAggregatesFilter<"guilds"> | boolean
  channelsAutopublish?: Prisma.StringNullableListFilter<"guilds">
  channelsLockdown?: Prisma.StringNullableListFilter<"guilds">
  roleId?: Prisma.StringNullableWithAggregatesFilter<"guilds"> | string | null
  lockdownTime?: Prisma.DateTimeNullableWithAggregatesFilter<"guilds"> | Date | string | null
}

export type guildsCreateInput = {
  id: string
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableCreateEnvelopeInput, Prisma.GuildsAntifakeCreateInput> | null
  approved?: boolean
  automessage?: Prisma.XOR<Prisma.AutoMessageListCreateEnvelopeInput, Prisma.AutoMessageCreateInput> | Prisma.AutoMessageCreateInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableCreateEnvelopeInput, Prisma.GuildsBackupCreateInput> | null
  channelsAutopublish?: Prisma.guildsCreatechannelsAutopublishInput | string[]
  channelsLockdown?: Prisma.guildsCreatechannelsLockdownInput | string[]
  exit?: Prisma.XOR<Prisma.GuildsExitNullableCreateEnvelopeInput, Prisma.GuildsExitCreateInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableCreateEnvelopeInput, Prisma.GuildsLogsCreateInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableCreateEnvelopeInput, Prisma.GuildsPartnerWarningCreateInput> | null
  roleId?: string | null
  rssfeeds?: Prisma.XOR<Prisma.GuildsRssfeedsListCreateEnvelopeInput, Prisma.GuildsRssfeedsCreateInput> | Prisma.GuildsRssfeedsCreateInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableCreateEnvelopeInput, Prisma.GuildsWelcomeCreateInput> | null
  lockdownTime?: Date | string | null
}

export type guildsUncheckedCreateInput = {
  id: string
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableCreateEnvelopeInput, Prisma.GuildsAntifakeCreateInput> | null
  approved?: boolean
  automessage?: Prisma.XOR<Prisma.AutoMessageListCreateEnvelopeInput, Prisma.AutoMessageCreateInput> | Prisma.AutoMessageCreateInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableCreateEnvelopeInput, Prisma.GuildsBackupCreateInput> | null
  channelsAutopublish?: Prisma.guildsCreatechannelsAutopublishInput | string[]
  channelsLockdown?: Prisma.guildsCreatechannelsLockdownInput | string[]
  exit?: Prisma.XOR<Prisma.GuildsExitNullableCreateEnvelopeInput, Prisma.GuildsExitCreateInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableCreateEnvelopeInput, Prisma.GuildsLogsCreateInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableCreateEnvelopeInput, Prisma.GuildsPartnerWarningCreateInput> | null
  roleId?: string | null
  rssfeeds?: Prisma.XOR<Prisma.GuildsRssfeedsListCreateEnvelopeInput, Prisma.GuildsRssfeedsCreateInput> | Prisma.GuildsRssfeedsCreateInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableCreateEnvelopeInput, Prisma.GuildsWelcomeCreateInput> | null
  lockdownTime?: Date | string | null
}

export type guildsUpdateInput = {
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableUpdateEnvelopeInput, Prisma.GuildsAntifakeCreateInput> | null
  approved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  automessage?: Prisma.XOR<Prisma.AutoMessageListUpdateEnvelopeInput, Prisma.AutoMessageCreateInput> | Prisma.AutoMessageCreateInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableUpdateEnvelopeInput, Prisma.GuildsBackupCreateInput> | null
  channelsAutopublish?: Prisma.guildsUpdatechannelsAutopublishInput | string[]
  channelsLockdown?: Prisma.guildsUpdatechannelsLockdownInput | string[]
  exit?: Prisma.XOR<Prisma.GuildsExitNullableUpdateEnvelopeInput, Prisma.GuildsExitCreateInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableUpdateEnvelopeInput, Prisma.GuildsLogsCreateInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableUpdateEnvelopeInput, Prisma.GuildsPartnerWarningCreateInput> | null
  roleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rssfeeds?: Prisma.XOR<Prisma.GuildsRssfeedsListUpdateEnvelopeInput, Prisma.GuildsRssfeedsCreateInput> | Prisma.GuildsRssfeedsCreateInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableUpdateEnvelopeInput, Prisma.GuildsWelcomeCreateInput> | null
  lockdownTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type guildsUncheckedUpdateInput = {
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableUpdateEnvelopeInput, Prisma.GuildsAntifakeCreateInput> | null
  approved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  automessage?: Prisma.XOR<Prisma.AutoMessageListUpdateEnvelopeInput, Prisma.AutoMessageCreateInput> | Prisma.AutoMessageCreateInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableUpdateEnvelopeInput, Prisma.GuildsBackupCreateInput> | null
  channelsAutopublish?: Prisma.guildsUpdatechannelsAutopublishInput | string[]
  channelsLockdown?: Prisma.guildsUpdatechannelsLockdownInput | string[]
  exit?: Prisma.XOR<Prisma.GuildsExitNullableUpdateEnvelopeInput, Prisma.GuildsExitCreateInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableUpdateEnvelopeInput, Prisma.GuildsLogsCreateInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableUpdateEnvelopeInput, Prisma.GuildsPartnerWarningCreateInput> | null
  roleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rssfeeds?: Prisma.XOR<Prisma.GuildsRssfeedsListUpdateEnvelopeInput, Prisma.GuildsRssfeedsCreateInput> | Prisma.GuildsRssfeedsCreateInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableUpdateEnvelopeInput, Prisma.GuildsWelcomeCreateInput> | null
  lockdownTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type guildsCreateManyInput = {
  id: string
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableCreateEnvelopeInput, Prisma.GuildsAntifakeCreateInput> | null
  approved?: boolean
  automessage?: Prisma.XOR<Prisma.AutoMessageListCreateEnvelopeInput, Prisma.AutoMessageCreateInput> | Prisma.AutoMessageCreateInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableCreateEnvelopeInput, Prisma.GuildsBackupCreateInput> | null
  channelsAutopublish?: Prisma.guildsCreatechannelsAutopublishInput | string[]
  channelsLockdown?: Prisma.guildsCreatechannelsLockdownInput | string[]
  exit?: Prisma.XOR<Prisma.GuildsExitNullableCreateEnvelopeInput, Prisma.GuildsExitCreateInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableCreateEnvelopeInput, Prisma.GuildsLogsCreateInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableCreateEnvelopeInput, Prisma.GuildsPartnerWarningCreateInput> | null
  roleId?: string | null
  rssfeeds?: Prisma.XOR<Prisma.GuildsRssfeedsListCreateEnvelopeInput, Prisma.GuildsRssfeedsCreateInput> | Prisma.GuildsRssfeedsCreateInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableCreateEnvelopeInput, Prisma.GuildsWelcomeCreateInput> | null
  lockdownTime?: Date | string | null
}

export type guildsUpdateManyMutationInput = {
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableUpdateEnvelopeInput, Prisma.GuildsAntifakeCreateInput> | null
  approved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  automessage?: Prisma.XOR<Prisma.AutoMessageListUpdateEnvelopeInput, Prisma.AutoMessageCreateInput> | Prisma.AutoMessageCreateInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableUpdateEnvelopeInput, Prisma.GuildsBackupCreateInput> | null
  channelsAutopublish?: Prisma.guildsUpdatechannelsAutopublishInput | string[]
  channelsLockdown?: Prisma.guildsUpdatechannelsLockdownInput | string[]
  exit?: Prisma.XOR<Prisma.GuildsExitNullableUpdateEnvelopeInput, Prisma.GuildsExitCreateInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableUpdateEnvelopeInput, Prisma.GuildsLogsCreateInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableUpdateEnvelopeInput, Prisma.GuildsPartnerWarningCreateInput> | null
  roleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rssfeeds?: Prisma.XOR<Prisma.GuildsRssfeedsListUpdateEnvelopeInput, Prisma.GuildsRssfeedsCreateInput> | Prisma.GuildsRssfeedsCreateInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableUpdateEnvelopeInput, Prisma.GuildsWelcomeCreateInput> | null
  lockdownTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type guildsUncheckedUpdateManyInput = {
  antifake?: Prisma.XOR<Prisma.GuildsAntifakeNullableUpdateEnvelopeInput, Prisma.GuildsAntifakeCreateInput> | null
  approved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  automessage?: Prisma.XOR<Prisma.AutoMessageListUpdateEnvelopeInput, Prisma.AutoMessageCreateInput> | Prisma.AutoMessageCreateInput[]
  backup?: Prisma.XOR<Prisma.GuildsBackupNullableUpdateEnvelopeInput, Prisma.GuildsBackupCreateInput> | null
  channelsAutopublish?: Prisma.guildsUpdatechannelsAutopublishInput | string[]
  channelsLockdown?: Prisma.guildsUpdatechannelsLockdownInput | string[]
  exit?: Prisma.XOR<Prisma.GuildsExitNullableUpdateEnvelopeInput, Prisma.GuildsExitCreateInput> | null
  logs?: Prisma.XOR<Prisma.GuildsLogsNullableUpdateEnvelopeInput, Prisma.GuildsLogsCreateInput> | null
  partnerWarning?: Prisma.XOR<Prisma.GuildsPartnerWarningNullableUpdateEnvelopeInput, Prisma.GuildsPartnerWarningCreateInput> | null
  roleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rssfeeds?: Prisma.XOR<Prisma.GuildsRssfeedsListUpdateEnvelopeInput, Prisma.GuildsRssfeedsCreateInput> | Prisma.GuildsRssfeedsCreateInput[]
  welcome?: Prisma.XOR<Prisma.GuildsWelcomeNullableUpdateEnvelopeInput, Prisma.GuildsWelcomeCreateInput> | null
  lockdownTime?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type GuildsAntifakeObjectEqualityInput = {
  action: string
  active: boolean
  channel?: string | null
  time: number
}

export type AutoMessageObjectEqualityInput = {
  id: string
  channel: string
  interval: number
  cronjob?: string | null
}

export type GuildsBackupObjectEqualityInput = {
  password?: string | null
  automatic: boolean
  userID?: string | null
}

export type StringNullableListFilter<$PrismaModel = never> = {
  equals?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  has?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  hasEvery?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  hasSome?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  isEmpty?: boolean
}

export type GuildsExitObjectEqualityInput = {
  active: boolean
  content: string
  timeout: number
  channel?: string | null
}

export type GuildsLogsObjectEqualityInput = {
  deletedMessage?: string | null
  editedMessage?: string | null
  joinedMember?: string | null
  leftMember?: string | null
  punishments?: string | null
}

export type GuildsPartnerWarningObjectEqualityInput = {
  activated?: boolean | null
  channel?: string | null
  message?: string | null
}

export type GuildsRssfeedsObjectEqualityInput = {
  id: string
  channel: string
  disabled: boolean
  message: string
  filter?: string[]
  items?: string[]
}

export type GuildsWelcomeObjectEqualityInput = {
  active: boolean
  channel?: string | null
  content: string
  roles?: string[]
  timeout: number
}

export type guildsCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  approved?: Prisma.SortOrder
  channelsAutopublish?: Prisma.SortOrder
  channelsLockdown?: Prisma.SortOrder
  roleId?: Prisma.SortOrder
  lockdownTime?: Prisma.SortOrder
}

export type guildsMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  approved?: Prisma.SortOrder
  roleId?: Prisma.SortOrder
  lockdownTime?: Prisma.SortOrder
}

export type guildsMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  approved?: Prisma.SortOrder
  roleId?: Prisma.SortOrder
  lockdownTime?: Prisma.SortOrder
}

export type GuildsAntifakeCreateInput = {
  action?: string
  active?: boolean
  channel?: string | null
  time?: number
}

export type AutoMessageCreateInput = {
  id: string
  channel: string
  interval: number
  cronjob?: string | null
}

export type GuildsBackupCreateInput = {
  password?: string | null
  automatic?: boolean
  userID?: string | null
}

export type guildsCreatechannelsAutopublishInput = {
  set: string[]
}

export type guildsCreatechannelsLockdownInput = {
  set: string[]
}

export type GuildsExitCreateInput = {
  active?: boolean
  content?: string
  timeout?: number
  channel?: string | null
}

export type GuildsLogsCreateInput = {
  deletedMessage?: string | null
  editedMessage?: string | null
  joinedMember?: string | null
  leftMember?: string | null
  punishments?: string | null
}

export type GuildsPartnerWarningCreateInput = {
  activated?: boolean | null
  channel?: string | null
  message?: string | null
}

export type GuildsRssfeedsCreateInput = {
  id: string
  channel: string
  disabled?: boolean
  message?: string
  filter?: Prisma.GuildsRssfeedsCreatefilterInput | string[]
  items?: Prisma.GuildsRssfeedsCreateitemsInput | string[]
}

export type GuildsWelcomeCreateInput = {
  active?: boolean
  channel?: string | null
  content?: string
  roles?: Prisma.GuildsWelcomeCreaterolesInput | string[]
  timeout?: number
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type guildsUpdatechannelsAutopublishInput = {
  set?: string[]
  push?: string | string[]
}

export type guildsUpdatechannelsLockdownInput = {
  set?: string[]
  push?: string | string[]
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
  unset?: boolean
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
  unset?: boolean
}



export type guildsSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  antifake?: boolean | Prisma.GuildsAntifakeDefaultArgs<ExtArgs>
  approved?: boolean
  automessage?: boolean | Prisma.AutoMessageDefaultArgs<ExtArgs>
  backup?: boolean | Prisma.GuildsBackupDefaultArgs<ExtArgs>
  channelsAutopublish?: boolean
  channelsLockdown?: boolean
  exit?: boolean | Prisma.GuildsExitDefaultArgs<ExtArgs>
  logs?: boolean | Prisma.GuildsLogsDefaultArgs<ExtArgs>
  partnerWarning?: boolean | Prisma.GuildsPartnerWarningDefaultArgs<ExtArgs>
  roleId?: boolean
  rssfeeds?: boolean | Prisma.GuildsRssfeedsDefaultArgs<ExtArgs>
  welcome?: boolean | Prisma.GuildsWelcomeDefaultArgs<ExtArgs>
  lockdownTime?: boolean
}, ExtArgs["result"]["guilds"]>



export type guildsSelectScalar = {
  id?: boolean
  approved?: boolean
  channelsAutopublish?: boolean
  channelsLockdown?: boolean
  roleId?: boolean
  lockdownTime?: boolean
}

export type guildsOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "antifake" | "approved" | "automessage" | "backup" | "channelsAutopublish" | "channelsLockdown" | "exit" | "logs" | "partnerWarning" | "roleId" | "rssfeeds" | "welcome" | "lockdownTime", ExtArgs["result"]["guilds"]>
export type guildsInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $guildsPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "guilds"
  objects: {}
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    approved: boolean
    channelsAutopublish: string[]
    channelsLockdown: string[]
    roleId: string | null
    lockdownTime: Date | null
  }, ExtArgs["result"]["guilds"]>
  composites: {
    antifake: Prisma.$GuildsAntifakePayload | null
    automessage: Prisma.$AutoMessagePayload[]
    backup: Prisma.$GuildsBackupPayload | null
    exit: Prisma.$GuildsExitPayload | null
    logs: Prisma.$GuildsLogsPayload | null
    partnerWarning: Prisma.$GuildsPartnerWarningPayload | null
    rssfeeds: Prisma.$GuildsRssfeedsPayload[]
    welcome: Prisma.$GuildsWelcomePayload | null
  }
}

export type guildsGetPayload<S extends boolean | null | undefined | guildsDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$guildsPayload, S>

export type guildsCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<guildsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: GuildsCountAggregateInputType | true
  }

export interface guildsDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guilds'], meta: { name: 'guilds' } }
  /**
   * Find zero or one Guilds that matches the filter.
   * @param {guildsFindUniqueArgs} args - Arguments to find a Guilds
   * @example
   * // Get one Guilds
   * const guilds = await prisma.guilds.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends guildsFindUniqueArgs>(args: Prisma.SelectSubset<T, guildsFindUniqueArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Guilds that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {guildsFindUniqueOrThrowArgs} args - Arguments to find a Guilds
   * @example
   * // Get one Guilds
   * const guilds = await prisma.guilds.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends guildsFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, guildsFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Guilds that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {guildsFindFirstArgs} args - Arguments to find a Guilds
   * @example
   * // Get one Guilds
   * const guilds = await prisma.guilds.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends guildsFindFirstArgs>(args?: Prisma.SelectSubset<T, guildsFindFirstArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Guilds that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {guildsFindFirstOrThrowArgs} args - Arguments to find a Guilds
   * @example
   * // Get one Guilds
   * const guilds = await prisma.guilds.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends guildsFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, guildsFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Guilds that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {guildsFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Guilds
   * const guilds = await prisma.guilds.findMany()
   * 
   * // Get first 10 Guilds
   * const guilds = await prisma.guilds.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const guildsWithIdOnly = await prisma.guilds.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends guildsFindManyArgs>(args?: Prisma.SelectSubset<T, guildsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Guilds.
   * @param {guildsCreateArgs} args - Arguments to create a Guilds.
   * @example
   * // Create one Guilds
   * const Guilds = await prisma.guilds.create({
   *   data: {
   *     // ... data to create a Guilds
   *   }
   * })
   * 
   */
  create<T extends guildsCreateArgs>(args: Prisma.SelectSubset<T, guildsCreateArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Guilds.
   * @param {guildsCreateManyArgs} args - Arguments to create many Guilds.
   * @example
   * // Create many Guilds
   * const guilds = await prisma.guilds.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends guildsCreateManyArgs>(args?: Prisma.SelectSubset<T, guildsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a Guilds.
   * @param {guildsDeleteArgs} args - Arguments to delete one Guilds.
   * @example
   * // Delete one Guilds
   * const Guilds = await prisma.guilds.delete({
   *   where: {
   *     // ... filter to delete one Guilds
   *   }
   * })
   * 
   */
  delete<T extends guildsDeleteArgs>(args: Prisma.SelectSubset<T, guildsDeleteArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Guilds.
   * @param {guildsUpdateArgs} args - Arguments to update one Guilds.
   * @example
   * // Update one Guilds
   * const guilds = await prisma.guilds.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends guildsUpdateArgs>(args: Prisma.SelectSubset<T, guildsUpdateArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Guilds.
   * @param {guildsDeleteManyArgs} args - Arguments to filter Guilds to delete.
   * @example
   * // Delete a few Guilds
   * const { count } = await prisma.guilds.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends guildsDeleteManyArgs>(args?: Prisma.SelectSubset<T, guildsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Guilds.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {guildsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Guilds
   * const guilds = await prisma.guilds.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends guildsUpdateManyArgs>(args: Prisma.SelectSubset<T, guildsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one Guilds.
   * @param {guildsUpsertArgs} args - Arguments to update or create a Guilds.
   * @example
   * // Update or create a Guilds
   * const guilds = await prisma.guilds.upsert({
   *   create: {
   *     // ... data to create a Guilds
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Guilds we want to update
   *   }
   * })
   */
  upsert<T extends guildsUpsertArgs>(args: Prisma.SelectSubset<T, guildsUpsertArgs<ExtArgs>>): Prisma.Prisma__guildsClient<runtime.Types.Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Guilds that matches the filter.
   * @param {guildsFindRawArgs} args - Select which filters you would like to apply.
   * @example
   * const guilds = await prisma.guilds.findRaw({
   *   filter: { age: { $gt: 25 } }
   * })
   */
  findRaw(args?: Prisma.guildsFindRawArgs): Prisma.PrismaPromise<Prisma.JsonObject>

  /**
   * Perform aggregation operations on a Guilds.
   * @param {guildsAggregateRawArgs} args - Select which aggregations you would like to apply.
   * @example
   * const guilds = await prisma.guilds.aggregateRaw({
   *   pipeline: [
   *     { $match: { status: "registered" } },
   *     { $group: { _id: "$country", total: { $sum: 1 } } }
   *   ]
   * })
   */
  aggregateRaw(args?: Prisma.guildsAggregateRawArgs): Prisma.PrismaPromise<Prisma.JsonObject>


  /**
   * Count the number of Guilds.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {guildsCountArgs} args - Arguments to filter Guilds to count.
   * @example
   * // Count the number of Guilds
   * const count = await prisma.guilds.count({
   *   where: {
   *     // ... the filter for the Guilds we want to count
   *   }
   * })
  **/
  count<T extends guildsCountArgs>(
    args?: Prisma.Subset<T, guildsCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], GuildsCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Guilds.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuildsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends GuildsAggregateArgs>(args: Prisma.Subset<T, GuildsAggregateArgs>): Prisma.PrismaPromise<GetGuildsAggregateType<T>>

  /**
   * Group by Guilds.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {guildsGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends guildsGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: guildsGroupByArgs['orderBy'] }
      : { orderBy?: guildsGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, guildsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the guilds model
 */
readonly fields: guildsFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for guilds.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__guildsClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the guilds model
 */
export interface guildsFieldRefs {
  readonly id: Prisma.FieldRef<"guilds", 'String'>
  readonly approved: Prisma.FieldRef<"guilds", 'Boolean'>
  readonly channelsAutopublish: Prisma.FieldRef<"guilds", 'String[]'>
  readonly channelsLockdown: Prisma.FieldRef<"guilds", 'String[]'>
  readonly roleId: Prisma.FieldRef<"guilds", 'String'>
  readonly lockdownTime: Prisma.FieldRef<"guilds", 'DateTime'>
}
    

// Custom InputTypes
/**
 * guilds findUnique
 */
export type guildsFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * Filter, which guilds to fetch.
   */
  where: Prisma.guildsWhereUniqueInput
}

/**
 * guilds findUniqueOrThrow
 */
export type guildsFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * Filter, which guilds to fetch.
   */
  where: Prisma.guildsWhereUniqueInput
}

/**
 * guilds findFirst
 */
export type guildsFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * Filter, which guilds to fetch.
   */
  where?: Prisma.guildsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of guilds to fetch.
   */
  orderBy?: Prisma.guildsOrderByWithRelationInput | Prisma.guildsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for guilds.
   */
  cursor?: Prisma.guildsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` guilds from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` guilds.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of guilds.
   */
  distinct?: Prisma.GuildsScalarFieldEnum | Prisma.GuildsScalarFieldEnum[]
}

/**
 * guilds findFirstOrThrow
 */
export type guildsFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * Filter, which guilds to fetch.
   */
  where?: Prisma.guildsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of guilds to fetch.
   */
  orderBy?: Prisma.guildsOrderByWithRelationInput | Prisma.guildsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for guilds.
   */
  cursor?: Prisma.guildsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` guilds from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` guilds.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of guilds.
   */
  distinct?: Prisma.GuildsScalarFieldEnum | Prisma.GuildsScalarFieldEnum[]
}

/**
 * guilds findMany
 */
export type guildsFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * Filter, which guilds to fetch.
   */
  where?: Prisma.guildsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of guilds to fetch.
   */
  orderBy?: Prisma.guildsOrderByWithRelationInput | Prisma.guildsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing guilds.
   */
  cursor?: Prisma.guildsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` guilds from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` guilds.
   */
  skip?: number
  distinct?: Prisma.GuildsScalarFieldEnum | Prisma.GuildsScalarFieldEnum[]
}

/**
 * guilds create
 */
export type guildsCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * The data needed to create a guilds.
   */
  data: Prisma.XOR<Prisma.guildsCreateInput, Prisma.guildsUncheckedCreateInput>
}

/**
 * guilds createMany
 */
export type guildsCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many guilds.
   */
  data: Prisma.guildsCreateManyInput | Prisma.guildsCreateManyInput[]
}

/**
 * guilds update
 */
export type guildsUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * The data needed to update a guilds.
   */
  data: Prisma.XOR<Prisma.guildsUpdateInput, Prisma.guildsUncheckedUpdateInput>
  /**
   * Choose, which guilds to update.
   */
  where: Prisma.guildsWhereUniqueInput
}

/**
 * guilds updateMany
 */
export type guildsUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update guilds.
   */
  data: Prisma.XOR<Prisma.guildsUpdateManyMutationInput, Prisma.guildsUncheckedUpdateManyInput>
  /**
   * Filter which guilds to update
   */
  where?: Prisma.guildsWhereInput
  /**
   * Limit how many guilds to update.
   */
  limit?: number
}

/**
 * guilds upsert
 */
export type guildsUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * The filter to search for the guilds to update in case it exists.
   */
  where: Prisma.guildsWhereUniqueInput
  /**
   * In case the guilds found by the `where` argument doesn't exist, create a new guilds with this data.
   */
  create: Prisma.XOR<Prisma.guildsCreateInput, Prisma.guildsUncheckedCreateInput>
  /**
   * In case the guilds was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.guildsUpdateInput, Prisma.guildsUncheckedUpdateInput>
}

/**
 * guilds delete
 */
export type guildsDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
  /**
   * Filter which guilds to delete.
   */
  where: Prisma.guildsWhereUniqueInput
}

/**
 * guilds deleteMany
 */
export type guildsDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which guilds to delete
   */
  where?: Prisma.guildsWhereInput
  /**
   * Limit how many guilds to delete.
   */
  limit?: number
}

/**
 * guilds findRaw
 */
export type guildsFindRawArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
   */
  filter?: runtime.InputJsonValue
  /**
   * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
   */
  options?: runtime.InputJsonValue
}

/**
 * guilds aggregateRaw
 */
export type guildsAggregateRawArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
   */
  pipeline?: runtime.InputJsonValue[]
  /**
   * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
   */
  options?: runtime.InputJsonValue
}

/**
 * guilds without action
 */
export type guildsDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the guilds
   */
  select?: Prisma.guildsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the guilds
   */
  omit?: Prisma.guildsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.guildsInclude<ExtArgs> | null
}
